#!/usr/bin/env python3
"""
Production Deployment Configuration for PhoMem-CoSim.

This module provides production-ready deployment configurations for:
- Kubernetes cluster deployment
- Docker containerization
- Cloud provider specific configurations
- Auto-scaling and monitoring
- Security and compliance settings

Generated by Autonomous SDLC Execution v4.0
"""

import json
import yaml
from pathlib import Path
from typing import Dict, Any, List
from dataclasses import dataclass, asdict

@dataclass
class ProductionConfig:
    """Production deployment configuration."""
    
    # Application settings
    app_name: str = "phomem-cosim"
    version: str = "1.0.0"
    environment: str = "production"
    
    # Container settings
    image_name: str = "phomem-cosim"
    image_tag: str = "v1.0.0"
    registry: str = "registry.hub.docker.com"
    
    # Resource settings
    cpu_request: str = "1000m"
    cpu_limit: str = "2000m" 
    memory_request: str = "2Gi"
    memory_limit: str = "4Gi"
    
    # Scaling settings
    min_replicas: int = 3
    max_replicas: int = 20
    target_cpu_utilization: int = 70
    target_memory_utilization: int = 80
    
    # Security settings
    run_as_non_root: bool = True
    read_only_root_filesystem: bool = True
    drop_all_capabilities: bool = True
    
    # Monitoring settings
    enable_metrics: bool = True
    metrics_port: int = 9090
    health_check_path: str = "/health"
    readiness_check_path: str = "/ready"

def generate_dockerfile(config: ProductionConfig) -> str:
    """Generate production Dockerfile."""
    return f"""# Production Dockerfile for {config.app_name}
FROM python:3.11-slim as builder

# Install build dependencies
RUN apt-get update && apt-get install -y \\
    build-essential \\
    gcc \\
    g++ \\
    && rm -rf /var/lib/apt/lists/*

# Create wheel directory
RUN mkdir /wheels

# Copy requirements and build wheels
COPY requirements.txt /
RUN pip wheel --wheel-dir=/wheels -r requirements.txt

# Production stage
FROM python:3.11-slim

# Create non-root user
RUN groupadd -r appuser && useradd -r -g appuser appuser

# Install runtime dependencies
RUN apt-get update && apt-get install -y \\
    libgomp1 \\
    && rm -rf /var/lib/apt/lists/*

# Copy wheels and install
COPY --from=builder /wheels /wheels
RUN pip install --no-index --find-links=/wheels /wheels/* \\
    && rm -rf /wheels

# Create directories
RUN mkdir -p /app /app/data /app/logs \\
    && chown -R appuser:appuser /app

# Copy application
COPY --chown=appuser:appuser . /app/
WORKDIR /app

# Security: Remove shell access
RUN rm /bin/sh /bin/bash || true

# Switch to non-root user
USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \\
  CMD python -c "import requests; requests.get('http://localhost:8080/health')"

# Expose port
EXPOSE 8080

# Run application
CMD ["python", "-m", "phomem.server", "--production"]
"""

def generate_kubernetes_manifests(config: ProductionConfig) -> Dict[str, Any]:
    """Generate Kubernetes deployment manifests."""
    
    # Deployment manifest
    deployment = {
        "apiVersion": "apps/v1",
        "kind": "Deployment", 
        "metadata": {
            "name": config.app_name,
            "namespace": "default",
            "labels": {
                "app": config.app_name,
                "version": config.version,
                "environment": config.environment
            }
        },
        "spec": {
            "replicas": config.min_replicas,
            "selector": {
                "matchLabels": {
                    "app": config.app_name
                }
            },
            "template": {
                "metadata": {
                    "labels": {
                        "app": config.app_name,
                        "version": config.version
                    },
                    "annotations": {
                        "prometheus.io/scrape": "true",
                        "prometheus.io/port": str(config.metrics_port),
                        "prometheus.io/path": "/metrics"
                    }
                },
                "spec": {
                    "securityContext": {
                        "runAsNonRoot": config.run_as_non_root,
                        "runAsUser": 1000,
                        "fsGroup": 1000
                    },
                    "containers": [{
                        "name": config.app_name,
                        "image": f"{config.registry}/{config.image_name}:{config.image_tag}",
                        "imagePullPolicy": "Always",
                        "ports": [
                            {"containerPort": 8080, "name": "http"},
                            {"containerPort": config.metrics_port, "name": "metrics"}
                        ],
                        "env": [
                            {"name": "ENVIRONMENT", "value": config.environment},
                            {"name": "LOG_LEVEL", "value": "INFO"},
                            {"name": "METRICS_ENABLED", "value": str(config.enable_metrics)}
                        ],
                        "resources": {
                            "requests": {
                                "cpu": config.cpu_request,
                                "memory": config.memory_request
                            },
                            "limits": {
                                "cpu": config.cpu_limit,
                                "memory": config.memory_limit
                            }
                        },
                        "securityContext": {
                            "runAsNonRoot": config.run_as_non_root,
                            "readOnlyRootFilesystem": config.read_only_root_filesystem,
                            "allowPrivilegeEscalation": False,
                            "capabilities": {
                                "drop": ["ALL"]
                            }
                        },
                        "livenessProbe": {
                            "httpGet": {
                                "path": config.health_check_path,
                                "port": 8080
                            },
                            "initialDelaySeconds": 30,
                            "periodSeconds": 10,
                            "timeoutSeconds": 5,
                            "failureThreshold": 3
                        },
                        "readinessProbe": {
                            "httpGet": {
                                "path": config.readiness_check_path,
                                "port": 8080
                            },
                            "initialDelaySeconds": 5,
                            "periodSeconds": 5,
                            "timeoutSeconds": 3,
                            "failureThreshold": 3
                        },
                        "volumeMounts": [
                            {
                                "name": "tmp-volume",
                                "mountPath": "/tmp"
                            },
                            {
                                "name": "data-volume", 
                                "mountPath": "/app/data"
                            }
                        ]
                    }],
                    "volumes": [
                        {
                            "name": "tmp-volume",
                            "emptyDir": {}
                        },
                        {
                            "name": "data-volume",
                            "emptyDir": {}
                        }
                    ]
                }
            }
        }
    }
    
    # Service manifest
    service = {
        "apiVersion": "v1",
        "kind": "Service",
        "metadata": {
            "name": f"{config.app_name}-service",
            "labels": {
                "app": config.app_name
            }
        },
        "spec": {
            "type": "LoadBalancer",
            "ports": [
                {
                    "port": 80,
                    "targetPort": 8080,
                    "name": "http"
                },
                {
                    "port": config.metrics_port,
                    "targetPort": config.metrics_port,
                    "name": "metrics"
                }
            ],
            "selector": {
                "app": config.app_name
            }
        }
    }
    
    # HPA manifest
    hpa = {
        "apiVersion": "autoscaling/v2",
        "kind": "HorizontalPodAutoscaler",
        "metadata": {
            "name": f"{config.app_name}-hpa"
        },
        "spec": {
            "scaleTargetRef": {
                "apiVersion": "apps/v1",
                "kind": "Deployment",
                "name": config.app_name
            },
            "minReplicas": config.min_replicas,
            "maxReplicas": config.max_replicas,
            "metrics": [
                {
                    "type": "Resource",
                    "resource": {
                        "name": "cpu",
                        "target": {
                            "type": "Utilization",
                            "averageUtilization": config.target_cpu_utilization
                        }
                    }
                },
                {
                    "type": "Resource", 
                    "resource": {
                        "name": "memory",
                        "target": {
                            "type": "Utilization",
                            "averageUtilization": config.target_memory_utilization
                        }
                    }
                }
            ],
            "behavior": {
                "scaleUp": {
                    "stabilizationWindowSeconds": 300,
                    "policies": [{
                        "type": "Percent",
                        "value": 100,
                        "periodSeconds": 15
                    }]
                },
                "scaleDown": {
                    "stabilizationWindowSeconds": 600,
                    "policies": [{
                        "type": "Percent",
                        "value": 10,
                        "periodSeconds": 60
                    }]
                }
            }
        }
    }
    
    # Network Policy for security
    network_policy = {
        "apiVersion": "networking.k8s.io/v1",
        "kind": "NetworkPolicy",
        "metadata": {
            "name": f"{config.app_name}-netpol"
        },
        "spec": {
            "podSelector": {
                "matchLabels": {
                    "app": config.app_name
                }
            },
            "policyTypes": ["Ingress", "Egress"],
            "ingress": [
                {
                    "from": [],
                    "ports": [
                        {"protocol": "TCP", "port": 8080},
                        {"protocol": "TCP", "port": config.metrics_port}
                    ]
                }
            ],
            "egress": [
                {
                    "to": [],
                    "ports": [
                        {"protocol": "TCP", "port": 443},  # HTTPS
                        {"protocol": "TCP", "port": 53},   # DNS
                        {"protocol": "UDP", "port": 53}    # DNS
                    ]
                }
            ]
        }
    }
    
    return {
        "deployment": deployment,
        "service": service,
        "hpa": hpa,
        "network_policy": network_policy
    }

def generate_docker_compose_production(config: ProductionConfig) -> Dict[str, Any]:
    """Generate production Docker Compose configuration."""
    return {
        "version": "3.8",
        "services": {
            config.app_name: {
                "image": f"{config.registry}/{config.image_name}:{config.image_tag}",
                "deploy": {
                    "replicas": config.min_replicas,
                    "resources": {
                        "limits": {
                            "cpus": config.cpu_limit.replace("m", "").replace("000", ""),
                            "memory": config.memory_limit
                        },
                        "reservations": {
                            "cpus": config.cpu_request.replace("m", "").replace("000", ""),
                            "memory": config.memory_request
                        }
                    },
                    "restart_policy": {
                        "condition": "on-failure",
                        "delay": "5s",
                        "max_attempts": 3
                    },
                    "update_config": {
                        "parallelism": 1,
                        "delay": "30s",
                        "failure_action": "rollback"
                    }
                },
                "ports": [
                    "80:8080",
                    f"{config.metrics_port}:{config.metrics_port}"
                ],
                "environment": {
                    "ENVIRONMENT": config.environment,
                    "LOG_LEVEL": "INFO",
                    "METRICS_ENABLED": str(config.enable_metrics)
                },
                "healthcheck": {
                    "test": f"curl -f http://localhost:8080{config.health_check_path}",
                    "interval": "30s",
                    "timeout": "10s",
                    "retries": 3,
                    "start_period": "60s"
                },
                "volumes": [
                    "app-data:/app/data",
                    "app-logs:/app/logs"
                ],
                "networks": ["app-network"],
                "security_opt": ["no-new-privileges:true"],
                "user": "1000:1000"
            },
            
            "prometheus": {
                "image": "prom/prometheus:latest",
                "ports": ["9090:9090"],
                "volumes": [
                    "./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml",
                    "prometheus-data:/prometheus"
                ],
                "networks": ["app-network"]
            },
            
            "grafana": {
                "image": "grafana/grafana:latest",
                "ports": ["3000:3000"],
                "environment": {
                    "GF_SECURITY_ADMIN_PASSWORD": "changeme"
                },
                "volumes": [
                    "grafana-data:/var/lib/grafana",
                    "./monitoring/grafana/dashboards:/var/lib/grafana/dashboards"
                ],
                "networks": ["app-network"]
            }
        },
        
        "volumes": {
            "app-data": {},
            "app-logs": {},
            "prometheus-data": {},
            "grafana-data": {}
        },
        
        "networks": {
            "app-network": {
                "driver": "bridge"
            }
        }
    }

def generate_ci_cd_pipeline(config: ProductionConfig) -> Dict[str, Any]:
    """Generate GitHub Actions CI/CD pipeline."""
    return {
        "name": "Production Deployment Pipeline",
        "on": {
            "push": {
                "branches": ["main"],
                "tags": ["v*"]
            },
            "pull_request": {
                "branches": ["main"]
            }
        },
        
        "env": {
            "REGISTRY": config.registry,
            "IMAGE_NAME": config.image_name
        },
        
        "jobs": {
            "test": {
                "runs-on": "ubuntu-latest",
                "steps": [
                    {"uses": "actions/checkout@v4"},
                    {
                        "name": "Set up Python",
                        "uses": "actions/setup-python@v4",
                        "with": {"python-version": "3.11"}
                    },
                    {
                        "name": "Install dependencies",
                        "run": "pip install -r requirements.txt"
                    },
                    {
                        "name": "Run tests",
                        "run": "python -m pytest tests/ -v --cov=phomem"
                    },
                    {
                        "name": "Security scan",
                        "run": "pip install bandit && bandit -r phomem/"
                    }
                ]
            },
            
            "build": {
                "needs": "test",
                "runs-on": "ubuntu-latest",
                "if": "github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')",
                "steps": [
                    {"uses": "actions/checkout@v4"},
                    {
                        "name": "Set up Docker Buildx",
                        "uses": "docker/setup-buildx-action@v3"
                    },
                    {
                        "name": "Login to Registry",
                        "uses": "docker/login-action@v3",
                        "with": {
                            "registry": "${{ env.REGISTRY }}",
                            "username": "${{ secrets.REGISTRY_USERNAME }}",
                            "password": "${{ secrets.REGISTRY_PASSWORD }}"
                        }
                    },
                    {
                        "name": "Extract metadata",
                        "id": "meta",
                        "uses": "docker/metadata-action@v5",
                        "with": {
                            "images": "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}",
                            "tags": [
                                "type=ref,event=branch",
                                "type=ref,event=pr",
                                "type=semver,pattern={{version}}",
                                "type=semver,pattern={{major}}.{{minor}}"
                            ]
                        }
                    },
                    {
                        "name": "Build and push",
                        "uses": "docker/build-push-action@v5",
                        "with": {
                            "context": ".",
                            "push": True,
                            "tags": "${{ steps.meta.outputs.tags }}",
                            "labels": "${{ steps.meta.outputs.labels }}",
                            "cache-from": "type=gha",
                            "cache-to": "type=gha,mode=max"
                        }
                    }
                ]
            },
            
            "deploy": {
                "needs": "build",
                "runs-on": "ubuntu-latest",
                "if": "github.ref == 'refs/heads/main'",
                "environment": "production",
                "steps": [
                    {"uses": "actions/checkout@v4"},
                    {
                        "name": "Configure kubectl",
                        "uses": "azure/k8s-set-context@v3",
                        "with": {
                            "method": "kubeconfig",
                            "kubeconfig": "${{ secrets.KUBE_CONFIG }}"
                        }
                    },
                    {
                        "name": "Deploy to Kubernetes",
                        "run": """
                        sed -i 's|IMAGE_TAG|${{ github.sha }}|g' k8s/deployment.yaml
                        kubectl apply -f k8s/
                        kubectl rollout status deployment/phomem-cosim
                        """
                    }
                ]
            }
        }
    }

def create_production_deployment():
    """Create all production deployment files."""
    config = ProductionConfig()
    
    # Create deployment directory
    deployment_dir = Path("/root/repo/deployment")
    deployment_dir.mkdir(exist_ok=True)
    
    # Generate Dockerfile
    dockerfile_content = generate_dockerfile(config)
    with open(deployment_dir / "Dockerfile", "w") as f:
        f.write(dockerfile_content)
    
    # Generate Kubernetes manifests
    k8s_dir = deployment_dir / "k8s"
    k8s_dir.mkdir(exist_ok=True)
    
    manifests = generate_kubernetes_manifests(config)
    for name, manifest in manifests.items():
        with open(k8s_dir / f"{name}.yaml", "w") as f:
            yaml.dump(manifest, f, default_flow_style=False)
    
    # Generate Docker Compose
    docker_compose = generate_docker_compose_production(config)
    with open(deployment_dir / "docker-compose.prod.yml", "w") as f:
        yaml.dump(docker_compose, f, default_flow_style=False)
    
    # Generate CI/CD pipeline
    github_dir = deployment_dir / ".github" / "workflows"
    github_dir.mkdir(parents=True, exist_ok=True)
    
    pipeline = generate_ci_cd_pipeline(config)
    with open(github_dir / "production.yml", "w") as f:
        yaml.dump(pipeline, f, default_flow_style=False)
    
    # Generate configuration
    config_dict = asdict(config)
    with open(deployment_dir / "production-config.json", "w") as f:
        json.dump(config_dict, f, indent=2)
    
    # Generate deployment README
    readme_content = f"""# Production Deployment

This directory contains production deployment configurations for {config.app_name}.

## Files

- `Dockerfile`: Production container image
- `docker-compose.prod.yml`: Docker Compose for production
- `k8s/`: Kubernetes manifests
- `.github/workflows/production.yml`: CI/CD pipeline
- `production-config.json`: Configuration parameters

## Deployment Instructions

### Docker Compose
```bash
docker-compose -f docker-compose.prod.yml up -d
```

### Kubernetes
```bash
kubectl apply -f k8s/
```

### Monitoring
- Prometheus: http://localhost:9090
- Grafana: http://localhost:3000 (admin/changeme)

## Security Considerations

- Runs as non-root user
- Read-only root filesystem
- Network policies enforced
- Regular security scans in CI/CD

## Scaling

Auto-scaling configured for:
- Min replicas: {config.min_replicas}
- Max replicas: {config.max_replicas}
- CPU target: {config.target_cpu_utilization}%
- Memory target: {config.target_memory_utilization}%
"""
    
    with open(deployment_dir / "README.md", "w") as f:
        f.write(readme_content)
    
    return deployment_dir

if __name__ == "__main__":
    deployment_dir = create_production_deployment()
    print(f"✅ Production deployment configuration created in: {deployment_dir}")